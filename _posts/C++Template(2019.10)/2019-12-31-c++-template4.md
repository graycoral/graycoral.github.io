---
layout: post
title: "4. Type traits "
date: 2019-12-31 04:00:00 +0800
categories: C++ template
---

## type traits

1. **type traits 개념과 is_pointer**
   * type traits 개념과 is_pointer
   * type traits 개념
     1. 컴파일 시간에 타입에 대한 정보를 얻거나 변형 된 타입을 얻을 때 사용 하는 도구(메타함수)
     2. <type_traits> 헤더로 제공 됨(~C++11)

    ```cpp
    /*
        type query를 위한 type traits 만드는 일반적인 방법
        1. primary template에서 false 리턴
        2. partial specialization true 리턴
    */
    template<typename T> struct xis_pointer
    {
        /*
        bool value = false; // 초기화가 안된 시절이 있었다. (런타임 상수)
        complie time 상수를 얻기 위해 enum 을 사용함
        */
        //enum{   value = false; }
        // 타입을 명확히 나타내기 때문에 아래와 같이 사용
        static constexpr bool value = false;
    };

    template<typename T> struct xis_pointer<T*>
    {
        //enum{   value = true; }
        static constexpr bool value = true;
    };

    template<typename t> void foo(T v)
    {
        if(xis_pointer<t>::value) {
            cout << "pointer" << endl;
        } else{
            cout << "not pointer" << endl;
        }
    };

    int main()
    {
        int n =3;

        foo(n); // not pointer
        foo(&n); // pointer
        return 0;
    }
    ```

   ```cpp
    template<typename T> struct xis_pointer
    {
        static constexpr bool value = false;
    };

    template<typename T> struct xis_pointer<T*>
    {
        static constexpr bool value = true;
    };
    template<typename T> struct xis_pointer<T* const>
    {
        static constexpr bool value = true;
    };
    template<typename T> struct xis_pointer<T* volatile>
    {
        static constexpr bool value = true;
    };
    template<typename T> struct xis_pointer<T* const volatile>
    {
        static constexpr bool value = true;
    };

    int main()
    {
        cout << xis_pointer<int>::value << endl;
        cout << xis_pointer<int*>::value << endl;
        cout << xis_pointer<int* const>::value << endl;
        cout << xis_pointer<int* volatile>::value << endl;
        cout << xis_pointer<int* const volatile>::value << endl;
        cout << xis_pointer<int* volatile const>::value << endl;

        return 0;
    }
   ```

   * is_arry
     1. Primary template에서는 false 리턴(value = false)
     2. 배열 모양으로 부분 특수화 모양을 만들고 true 리턴
     3. 타입을 정확히 알아야 함
        - int x[3] 에서 타입 -> int[3]
     4. unknown size array type(T[])에 대해서도 부분 특수화를 제공 필요

    ```cpp
    template<typename T> struct xis_array
    {
        static constexpr bool value = false;
    };

    template<typename T, size_t N>
    struct xis_array<T[N]>
    {
        static constexpr bool value = true;
    };

    template<typename T>
    struct xis_array<T[]>
    {
        static constexpr bool value = true;
    };

    template<typename t> void foo(t& v)
    {
        if(xis_array<t>::value) {
            cout << "array" << endl;
        } else{
            cout << "not array" << endl;
        }
    };

    int main()
    {
        int x[3] = {1,2,3};
        foo(x);

        return 0;
    }
    ```
     + 핵심 정리
       1. 배열의 크기도 구할수 있음
        - c++ 11 : extent<T,0>::value
        -     2. 함수템플릿의 인자 값(T)으로 만들 경우 배열을 전달 하면 T의 타입은 배열이 아닌 포인터로 결정



2. **type traits 개념과 is_pointer**