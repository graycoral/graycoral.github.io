---
layout: post
title: "5. variadic template"
date: 2020-01-07 01:00:00 +0800
categories: C++ template
---

## variadic template

1. **type traits 개념과 is_pointer**
   * C++ 11 부터 지원
   * 가변인자 템플릿 기본 모양
   * 가변인자 템플릿의 템플릿 인자Types 는 여러개의 타입을 나타냄
   * 가변인자 함수 템플릿의의 함수 인자 args는 여러개의 값이 들어있다. ***Parameter Pack*** 이라고한다.

    ```cpp
    template<typename ...Types> class xtuple
    {
    };

    template<typename ... Types>
    void foo(Types ... args)
    {
    }

    int main()
    {
        xtuple<> t0;
        xtuple<int> t1;
        xtuple<int, char> t2;

        foo();
        foo(1);
        foo(1,3.4,"A");

        return 0;
    }
    ```

   * Parmeter Pack

    ```cpp
    void goo(int n, double d, const char* s)
    {
        cout << "goo : "  << n << " " << d << " "<< s << endl;
    }

    template<typename ... Types>
    void foo(Types ... args)
    {
        //args : Parameter Pack
        cout << sizeof ...(args) << endl; // 3
        cout << sizeof ...(Types) << endl; // 3

        goo(args...); // ***pack expansion***
                    // goo(e1, e2, e3);
                    // goo(1,3.4,"A");

    }

    int main()
    {
        // foo();
        // foo(1);
        foo(1,3.4,"A");

        return 0;
    }
    ```

    * pack expansion #1
      * pack expansion 패턴 ... -> 패던(e1, e2 e3)
      *  ... 위치를 주의 한다
         - goo(hoo(args...)) -> goo(hoo(e1, e2,e3));
         - goo(hoo(args)... ) -> goo(hoo(e1), hoo(e2),hoo(e3)));
      * pack expansion은 함수의 호출의 인자 또는 list 초기화를 사용한 표현식에 서만 사용할수 있다

    ```cpp
    void goo(int n, double d, const char* s)
    {
        cout << "goo : "  << n << " " << d << " "<< s << endl;
    }

    int hoo(int a) {return -a;}

    template<typename ... Types>
    void foo(Types ... args)
    {
        // int x[] = {args...}  ; // ***pack expansion***
        //                      // {1,2,3}
        //int x[] = {(++args)...}; // ***pack expansion***
                            // {e1,e2,e3}
                            // {2,3,4}
        // int x[] = {hoo(args...)}; // hoo(1,2,3)  error
        int x[] = {hoo(args)... }; //hoo(1), hoo(2). hoo(3)
        for( auto n : x)
        {
            cout << n << endl;
        }
    }

    int main()
    {
        foo(1,2,3);

        return 0;
    }
    ```

    ```cpp
    int print(int a)
    {
        cout << a << ",";
        return 0;
    }

    template<typename ... Types>
    void foo(Types ... args)
    {
        //print(args); // error
        //print(args...);  // print(1,2,3) error

        //print(args)...; //print(1), print(2), print(3) error
        // 전역적인 공간에서는 안됨
        // int x[] = {print(args)...}; // {print(1),print(2),print(3)}; //foo()=에서 에러 발생
        // int x[] = {0, print(args)...}; // {print(1),print(2),print(3)};
        // int x[] = {0, (print(args),0)...}; //  {0, (print(1),0), (print(2),0), (print(3),0)}
        initializer_list<int> e = {(print(args),0)...};
    }

    int main()
    {
        foo();
        // foo(1,2,3); //args : 1,2,3
        return 0;
    }
    ```

    * pack expansion #2
    ```cpp
    template<typename ... Types>
    void foo(Types ... args)
    {
        int x[] = { args... };

        pair<Types...> p1; // pair<int ,double> p1;
        tuple<Types...> t1; // tuple<int, doulbe> t1;

        tuple<pair<Types...>> t2;// tuple<pair<int,double>> t2; // ok
        tuple<pair<Types>...> t3;// tuple<pair<int>,pair<double>> t3; // error

        tuple<pair<int, Types>...> t4; // tuple<pair<int,int>,pair<int, double>> t4;

        pair<tuple<Types...>> p2; // pair<tuple<int,doulbe>> p2; //error
        pair<tuple<Types>...> p3;// pair<tuple<int>, tuple<double>> p3;// ok

    }

    int main()
    {
        foo(1,2.3); //args : 1,2.3
        return 0;
    }
    ```

2. **recursion**

    *  parameter pack에서 각 요소를 꺼내는 방법
       *  Pack Expanstion -> 배열 또는 tuple에 담는다
       *  재귀 호출과 유사한 호출식을 사용한다.
          *  모든 인자를 가변인자로 하지말고, 1번째 인자는 이름 있는 변수로 받는다.
       *  fold Expression -> C++17
    ```cpp
    template<typename ... Types>
    void foo(Types ... args)
    {
        //int x[] = {args...};
        tuple<Types ...> tp(args...);

        cout << get<0>(tp) << endl;
        cout << get<1>(tp) << endl;
        cout << get<2>(tp) << endl;
    }

    int main()
    {

        foo(1,2.3, "A"); //args : 1,2.3,"A"
        return 0;
    }

    #elif TEST == 2

    void foo() {} // 재귀의 종료를 위해서

    template<typename T, typename ... Types>
    void foo(T value, Types ... args)
    {
        cout << value << endl;

        foo(args...); // foo (3.4, "AA")
                    // foo ("AA")
                    // foo ()
    }

    int main()
    {

        foo(1,2.3, "A"); //value : 1, args : 2.3,"A"
        return 0;
    }
    ```

