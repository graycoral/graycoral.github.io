---
layout: post
title: "Unit Test Framework : Warming Up"
date: 2021-04-21 01:00:00 +0800
categories: Unit Test
---

# 소프트웨어 테스팅

## 소프트웨어 테스트 원칙 7

**1. ㅁㄴㅇㄻㄴㅇㄹ**
**2. ㅁㄴㅇㄻㄴㅇㄹ**
   1. 테스팅은 결함이 존재함을 밝히는것
   2. 완벽한 테스팅은 불가능하다
      1. 무한 경로
      2. 무한 입력 값
      3. 무한 타이밍
   3. 완벽한 테스팅 대신에 **리스크 분석 과 결정된 우선 순위에 따라 수행해야함**
**3. 개발 초기에 테스팅 시작**
   1. 개발 시작과 동시에 테스트를 계획
   2. 초기부터 준비된 테스트 케이스를 레벨별로 실해하게 되므로 테스팅 결과를 단기간에 파악할 수 있고, 개발 후반에 발견 될 결함을 예방할 수 있다.
   3. 테스팅 팀이 독립적일 경우, 객관적이고 깊이 있는 테스팅 수행 가능
4. 결함 집중 현상
   1. 많은 결함들이 특정 기능 또는 모듈에 집중되어 발생된다.
   2. 결함이 집중될 가능성이 높은 모듈 특징
      1. 복잡한 구조
      2. 다른 시스템 또는 모듈과 복잡하고 많은 상호작용을 함
      3. 새롭게 시작
      4. 경험이 부족한 개발팀에서 개발한 모듈
5. 살충제 패러독스
   1. 동일한 테스트가 반복적으로 수행된다면 새로운 버그를 찾지 못한다.
6. ㅁㅇㅁㄴㅇㄹ
7. 오류 부재의 궤변
   1. 오류가 없어도 사용자의 요구에 맞지 않는다면 테스팅의 결과는 의미가 없다
   2. 이런 경우 품질이 높다고 할 수 없다


## 단위 테스트 정의

* 다른 코드를 호출한 후, 몇가지 가정이 성립 되는지 검사하는 코드
* 가정이 성립 되지 않으면 단위 테스트는 실패
* SUT : 테스트 대상 시스템
  * 테스트 대상 코드 (COde Under Test)
  * 클래스 대상 코드 (Class Under Test)

## 통합 테스트 정의

* 전체 시스템 통합이 완료 될때까지 소프트웨어 하드웨어 구성 요소들이 결합되어 테스트 되는 질서 정연한 테스트 과정 - 빌허첼

* 두 개이상의 독립적인

## 단위 테스트 작성 비용

* 단위 테스트 작성하기 위한 기술과 비용은 발생한다.
* 시간이 지나면, 추가적으로 발생하는 비용 전부를 이득으로 벌출하는 안정적인 상태에 도달한다.

## 단위 테스트의 가치

* 통합 테스트는 테스트가 실패 할수 있는 지점이 여러곳 존재한다.
* 문제의 근원지를 찾아내는 것이 어렵다.
* 단위 테스트는 하나의 단위에 대한 테스트를 수행함으로써 어디서 문제가 발생했는지를 빠르게 찾을 수 있다.
* 결함 국소화
  * 어떤 테스트가 실패했는지를 보고 버그가 무었인지를 금방 알아 낼 수 있다.
* 코드를 변경한 후 이전에 잘 동작하던 모든 기능들이 아직도 제대로 작동하는지 여부를 어떻게 검증할 수 있는가?
* 단위 테스트는 '우발적 버그 생성' 을 막아준다
* 레거시 코드 수정의 안정망을 제공한다.
* 회귀 테스트 스위트가 갖춰진 코드로 작업을 한다면 훨씬 빠르게 작업을 할 수 있으며, 실험적인 방법으로 소프트웨어를 변경 할 수 있다.
* **레거시 코드 : 회귀테스트 스위트가 없는 코드를 의미한다. -레거시 코드 활용 전략-**
* 개발자의 코딩 부담은 증가
* 하지만 결함이 감소하기 때문에, 전체 소프트웨어 개발 비용은 감소한다.

## 단위 테스트 작성 방법

* **테스트는 SUT 를 이해하는데 도움이 되어야한다.**
  * 완전 자동 테스트 : 수동 조정 없이 돌려 볼 수 있어야한다.
  * 자체 검사 테스트 : 직접 검사해보지 않아도 에러를 찾아내 알려 줄 수 있어야한다.
  * 반복되는 테스트 : 여러번 돌려 봐도 같은 결과를 얻을 수 있어야한다.
  * 독립적인 테슽으 : 테스트 별로 돌려볼 수 있어야한다.

* 단위 테스트는 만들고 유지하기 쉬워야한다.
  * 단순한 테스트 : 단위 테스트는 작아야하고, 한번에 하나만 테스트 해야한다.
* 단위 테스트에 필요한 유지 보슈 비용이 최소화 되어야한다.
  * 하나를 변경하였을 떄 영향 받는 테스트 수가 최소가 될 수 있는 방법으로 테스트를 작성해야 한다.
  * SUT를 최대한 격리시켜, 테스트 환경이 변경 되어도 테스트에는 아무런 영향이 없게 해야한다.

## 테스를 작성하는 견해

* 외부모듈 부터 ? 내부 모듈 부터?
  * 안에서 밖으로
    * 의존관계를 해결하지 않아도 된다.
    * 가장 내부 컴포넌트부터 개발을 시작해 이를 기반ㅇ으로 점차 사용자 인터페이스까지 개발
  * 밖에서 안으로
    * 밖에서 부터 개발을 시작해 어떤 의존 컴포넌트가 필요한지를 봐서 구현

* 상태를 검증? 동작을 검증?
  * 상태 검증
    * SUT를특정 상태에 두고 실행한 후 SUT가 원했던 상태인지 검증
    * 쉽다!!
  * 동작 검증
    * SUT의 시작과 끝의 상태뿐 아니라, SUT가 내부적으로 호출하는 것까지 검증
    * 모의 객체나 테스트 스파이를 많이 사용
    * 어렵다!!!

## xUnit Test Framework

* SUnit / JUnit 등등
* 객체지향을 기반으로 하는 테스트 지향
* 객체지향이 아니면 한계도 있다

* 특징
  * Test Runner : 테스트 실행하는 프로그램 with xUnit Framework and repots the test results
  * Test Case : A test case is most elemental calss. All Unit test are inherited from here.
  * Tetst Fixtures : A test fixture is the set of preconditions or state needed to run a test. The delveoper should set up a knwon good state before the tests, and return to original state after the tests.
  * Test Suites
    * A test suites is a set of tests thal all share the same fixture.
  * Test Execution
  * Test Result Formatter
    * A test runner produces results in one or more output formats. In additional to a plain, human-readable formant, there is often a test reust formmater that produces XML output.
  * Assertions
    * An assertion is a fucntion or macro that verifies the behabior of the unit under test.
